**Отчет ДЗ №1 Работа с уровнями изоляции транзакции в PostgreSQL**  
  
1. Создана ВМ. ОС Linux Ubuntu. PostgreSQL версия 14.  
  
1. Установлен Dbeaver, настроено соединение с БД.  
  
1. Открываем 2 соединения.  
  
1. Отключаем авто-коммиты.  
  
1. В первом соединении создаем и заполняем таблицу данными:  
	*create table persons(id serial, first_name text, second_name text);*   
	*insert into persons(first_name, second_name) values('ivan', 'ivanov');*  
	*insert into persons(first_name, second_name) values('petr', 'petrov');*   
	*commit;*  
	
	далее смотрим уровень изоляции:    	
	*show transaction isolation level;* --read committed  	
  
1. Начинаем новую транзакцию с тем же уровнем изоляции.  
  
1. В первом соединении добавляем строку в таблицу:  	
	*insert into persons(first_name, second_name) values('sergey', 'sergeev');*  
  
1. Во втором соединении выполняем:  
	*select * from persons;* --нет новой строки  
	т.к.  
	**Read Committed** — уровень изоляции транзакции, выбираемый в Postgres Pro по умолчанию. В транзакции, работающей на этом уровне,   
	запрос SELECT (без предложения FOR UPDATE/SHARE) видит только те данные, которые были зафиксированы до начала запроса;   
	он никогда не увидит незафиксированных данных или изменений, внесённых в процессе выполнения запроса параллельными транзакциями.   
	По сути запрос SELECT видит снимок базы данных в момент начала выполнения запроса.  
  
	При этом в первом соединении, до завершения транзации *select * from persons;* -- выводит новую строку  
  
1. В первом соединении завершаем транзакцию:  
*commit;* -- завершение транзакции
  
1. Во втором соединении выполняем:
*select * from persons;* --есть новая строка, из-за уровня изоляции, описанном выше
  
1. Завершаем транзакции.
  
1. Реализуем новые транзакции с типом repeatable read (также отключаем авто-коммит).  
  
1. В первом соединении создаем новую строку:  
	*insert into persons(first_name, second_name) values('sveta', 'svetova');*  
  
1. Во втором соединении выполняем:  
	*select * from persons;* --нет новой строки
  
	В режиме Repeatable Read видны только те данные, которые были зафиксированы до начала транзакции,   
	но не видны незафиксированные данные и изменения,  
	произведённые другими транзакциями в процессе выполнения данной транзакции.   
	(Однако запрос будет видеть эффекты предыдущих изменений в своей транзакции, несмотря на то, что они не зафиксированы.)   
	Это самое строгое требование, которое стандарт SQL вводит для этого уровня изоляции. Это не противоречит стандарту,   
	так как он определяет только минимальную защиту, которая должна обеспечиваться на каждом уровне изоляции.  
  
	Этот уровень отличается от Read Committed тем, что запрос в транзакции данного уровня видит   
	снимок данных на момент начала первого оператора в транзакции (не считая команд управления транзакциями), а не начала текущего оператора.   
	Таким образом, последовательные команды SELECT в одной транзакции видят одни и те же данные;   
	они не видят изменений, внесённых и зафиксированных другими транзакциями после начала их текущей транзакции.  

	Поэтому после commit в первом соединении, во втором соединении при выполнении *select * from persons;* --все еще нет новой строки.  
  
1. После commit (завершения транзакции) во втором соединении при выполнении *select * from persons;* новая строка появилась.
