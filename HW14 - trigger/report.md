**Отчет ДЗ №14 Триггеры, поддержка заполнения витрин**  
   
	Требуется:   
	- Создать триггер для поддержки витрины в актуальном состоянии     
	
  
	Теория   
   
	Триггеры в SQL - это специальные хранимые процедуры, которые автоматически выполняются в ответ на определенные события, происходящие в базе данных.   
  
	Основные задачи триггеров:  

	1. Обеспечение целостности данных:
	- Проверка ограничений: Триггер может проверять соблюдение бизнес-правил, которые не могут быть реализованы обычными ограничениями (constraints).  
		Например, он может предотвратить добавление дублирующих записей, проверять соответствие значений в разных таблицах, проверять корректность формата вводимых данных.  
	- Запрет удаления данных:  Триггер может предотвращать удаление данных, если это нежелательно или нарушает целостность других таблиц.  
	- Автоматическое обновление данных:  Триггер может автоматически обновлять значения в других таблицах при изменении данных в одной из них, чтобы поддерживать целостность и согласованность информации.  
  
	2. Автоматизация действий:  
    - Логирование событий:  Триггер может записывать информацию о изменениях в базе данных в отдельные таблицы аудита, чтобы отслеживать действия пользователей, изменения данных и т.д.  
    - Создание уведомлений:  Триггер может отправлять уведомления пользователям или другим системам о событиях, например, о  создании  новой  записи  или  изменении  статуса.  
    - Выполнение  других  действий:  Триггер  может  вызывать  другие  процедуры  или  функции  для  дополнительной  обработки  данных.  

	3. Управление бизнес-логикой:  
    - Триггеры могут реализовывать сложные бизнес-правила, которые  не  могут  быть  реализованы  с  помощью  простых  ограничений.   
		Например, они  могут  проверять  условия  для  создания  записи,  отслеживать  изменения  и  вносить  необходимые  корректировки.  
  
	Преимущества использования триггеров:    
    - Автоматизация:  Триггеры  автоматически  выполняются  при  происхождении  определенного  события,  что  упрощает  разработку  и  поддерживает  целостность  данных.  
    - Контроль над изменениями:  Триггеры  позволяют  ввести  строгие  правила  и  контролировать  изменения  в  базе  данных.  
    - Улучшенная  безопасность:  Триггеры  могут  предотвратить  несанкционированное  изменение  данных  или  нарушение  целостности  базы  данных.  
  
	Недостатки:  
    - Сложность:  Триггеры  могут  быть  сложны  в  разработке  и  отладке,  особенно  для  сложних  бизнес-правил.  
    - Производительность:  Триггеры  могут  уменьшить  производительность  запросов,  так  как  они  выполняются  дополнительно  к  основным  операциям  над  данными.  

	Таким образом:  
	Триггеры  -  это  мощный  инструмент  в  SQL,  который  позволяет  управлять  целостностью  данных,  автоматизировать  действия  и  реализовывать  сложные  бизнес-правила.     
	Однако,  их  использование  требует  тщательного  планирования  и  отладки,  чтобы  обеспечить  надежность  и  производительность  базы  данных.  
  
  
 
   
1. Создала нужную схему и таблицы  
  
	*DROP SCHEMA IF EXISTS pract_functions CASCADE;  
	CREATE SCHEMA pract_functions;*  
  
	*SET search_path = pract_functions, publ*  
  
	-- товары:  
	*CREATE TABLE goods  
	(  
		goods_id    integer PRIMARY KEY,  
		good_name   varchar(63) NOT NULL,  
		good_price  numeric(12, 2) NOT NULL CHECK (good_price > 0.0)  
	);*  
  
	*INSERT INTO goods (goods_id, good_name, good_price)  
	VALUES 	(1, 'Спички хозайственные', .50),  
			(2, 'Автомобиль Ferrari FXX K', 185000000.01);*  
  
	-- Продажи  
	*CREATE TABLE sales  
	(  
		sales_id    integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,  
		good_id     integer REFERENCES goods (goods_id),  
		sales_time  timestamp with time zone DEFAULT now(),  
		sales_qty   integer CHECK (sales_qty > 0)  
	);*  
  
	*INSERT INTO sales (good_id, sales_qty) VALUES (1, 10), (1, 1), (1, 120), (2, 1);*  
  
	-- отчет:  
	*SELECT G.good_name, sum(G.good_price * S.sales_qty)  
	FROM goods G  
	INNER JOIN sales S ON S.good_id = G.goods_id  
	GROUP BY G.good_name;*  
  
	-- с увеличением объёма данных отчет стал создаваться медленно  
	-- Принято решение денормализовать БД, создать таблицу  
  	
	*CREATE TABLE good_sum_mart  
	(  
		good_name   varchar(63) NOT NULL,  
		sum_sale	numeric(16, 2)NOT NULL  
	);*  
  
  
	Денормализация таблицы в SQL - это процесс добавления избыточных данных в таблицу, чтобы оптимизировать производительность запросов, нарушая при этом правила нормализации данных.   
  
	Нормализация данных - это процесс организации данных в таблицы с минимальной избыточностью и максимальной согласованностью.  
	Она основана на правилах, называемых нормальными формами, чтобы избежать проблем с повторяющимися данными, несогласованностью и сложностью обновления.  
  
	Денормализация - это, по сути, нарушение этих правил, но с целью оптимизации производительности:  
  
	Причины для денормализации:    
	• Улучшение производительности запросов:   
		- Денормализация может ускорить выполнение запросов, особенно сложных, которые требуют объединения данных из нескольких таблиц.  
		- Избыточные данные уменьшают количество необходимых соединений (joins) между таблицами.  
		- Это особенно важно для приложений с высокой нагрузкой и требованиями к быстрому отклику.  
  
	• Упрощение логики запросов: 
		- Денормализация может упростить запросы, так как они могут обращаться к одной таблице вместо нескольких. Это делает запросы более читаемыми и понятными.  
  
	Примеры денормализации:  
	• Добавление дополнительных столбцов: В таблицу customers можно добавить столбец last_order_date,  
		который хранит дату последнего заказа клиента, чтобы избегать соединения с таблицей orders при получении этой информации.  
	• Дублирование данных: В таблицу products можно добавить столбец category_name,  
		который содержит название категории товара, чтобы избегать соединения с таблицей categories при выводе информации о товаре.  
  
	Недостатки денормализации:  
	• Потенциал для несогласованности данных: Изменения в одной таблице могут не быть автоматически отражены в других, что может привести к несогласованным данным.  
	• Усложнение обновления данных: Обновление денормированных таблиц может быть более сложным и требовать дополнительного кода для поддержания согласованности данных.  
	• Потеря возможностей нормализации: Денормализация может свести на нет преимущества нормализации, такие как минимальная избыточность и улучшенная целостность данных.  
  
	Когда использовать денормализацию:  
	• Денормализацию следует использовать с осторожностью и только в случаях, когда производительность запросов является критическим фактором.  
	• Если у вас есть возможность использовать другие методы оптимизации (индексы, кэширование), то следует постараться избежать денормализации.  
  
	Таким образом:  
	Денормализация - это компромисс между производительностью и целостностью данных. Необходимо тщательно взвесить преимущества и недостатки, прежде чем применять ее в своем проекте.  
  
  
  
	Создала функцию для триггера    
  	
	![рис.1](https://github.com/tulenevak/otus-PostgreSQL-2024-03-tuleneva/tree/main/HW14%20-%20trigger/image/im1.jpg)   
  
  
	Создала триггер   
  	
	![рис.2](https://github.com/tulenevak/otus-PostgreSQL-2024-03-tuleneva/tree/main/HW14%20-%20trigger/image/im2.jpg)   	 
  
  	
	Задание со *    
  
	Преимущества схемы (витрина + триггер):  

	Актуальность данных:  
	  - Триггер, связанный с витриной, гарантирует, что данные в витрине будут обновляться автоматически после каждого изменения в исходных таблицах.   
		Это означает, что отчеты, основанные на витрине, всегда будут использовать актуальную информацию.  
	  - Отчет "по требованию" может использовать устаревшие данные, если изменения цен произошли между моментом создания отчета и его запросом.  
  
	Консистентность данных:  
	  - Триггер, работающий при изменении цены, гарантирует, что изменения будут отражены во всех таблицах, участвующих в формировании витрины.  
		Это предотвращает несоответствия и гарантирует, что все отчеты, основанные на витрине, будут использовать одинаковые цены.  
	  - Отчет "по требованию" может использовать разные цены из разных источников, если они были обновлены не синхронно, что приведет к неточностям в анализе.  
  
	Сокращение нагрузки на производственную базу данных:  
	  - Витрина работает как промежуточный слой, защищая основную базу данных от непосредственных запросов. Это особенно важно при частых запросах отчетов, что снижает нагрузку на сервер.    
	  - Отчет "по требованию" может создавать дополнительную нагрузку на сервер при каждом запросе.  
  
	Упрощение логики:  
	  - Триггеры могут управлять обновлением витрины автоматически, без необходимости писать дополнительный код для обновления отчета.  
	  - Отчет "по требованию" может потребовать дополнительного кода для обновления и создания нового отчета при изменении цен.  
  
	Управление доступом:    
	  - Витрина может быть настроена так, что пользователи имеют доступ только к ее данным, не имея полного доступа к исходным таблицам. Это улучшает безопасность и контроль над данными.  
	  - Отчет "по требованию" может потребовать предоставления доступа к исходным таблицам, что может быть нежелательным с точки зрения безопасности.  
  
	Важно отметить:  
	• Создание и поддержка витрины требуют дополнительных ресурсов и времени.  
	• Выбор между витриной и отчетом "по требованию" зависит от конкретных требований проекта.  

	Таким образом:  
	Витрина с триггером предлагает более актуальные, консистентные и безопасные данные для отчетности по сравнению с отчетом "по требованию", особенно при изменении цен в реальном времени.    
  
  
    
	**Доработка по замечаниям**
  
	Переделала функцию для триггера:  
     
	CREATE OR REPLACE FUNCTION pract_functions.fun_change_sales_qty()  
    RETURNS trigger  
    AS  
    $$  
    DECLARE    
    BEGIN  
        IF TG_LEVEL = 'ROW' THEN  
  
	      INSERT INTO pract_functions.good_sum_mart(good_name, sum_sale)  
	        SELECT g.good_name, sum(g.good_price * s.sales_qty) as sum_sale  
	        FROM pract_functions.goods g  
	        INNER JOIN pract_functions.sales s ON s.good_id = g.goods_id  
	        WHERE s.good_id = coalesce(new.good_id, old.good_id)  
	        GROUP BY G.good_name  
	      on conflict (good_name) do   
	        update set sum_sale = EXCLUDED.sum_sale;  
  
        END IF;  
  
        RETURN CASE WHEN TG_OP = 'DELETE' THEN old ELSE new END;   
    END;    
    $$ LANGUAGE plpgsql;  
 
  
	В таблицу sales добавила строку  
	*insert into pract_functions.sales (good_id,sales_time,sales_qty) values (2,'01.01.2024'::Date,125);*  
  	
	![рис.3](https://github.com/tulenevak/otus-PostgreSQL-2024-03-tuleneva/tree/main/HW14%20-%20trigger/image/im3.jpg)   	 
    
	В таблице good_sum_mart появилась строка (сумма по продажам Автомобиля в количестве 1+125 штук)  
  	
	![рис.4](https://github.com/tulenevak/otus-PostgreSQL-2024-03-tuleneva/tree/main/HW14%20-%20trigger/image/im4.jpg)   	 
    
	Изменила данные в sales   
	*update pract_functions.sales set sales_qty = 200 where sales_id = 8;*  
  	
	![рис.5](https://github.com/tulenevak/otus-PostgreSQL-2024-03-tuleneva/tree/main/HW14%20-%20trigger/image/im5.jpg)   	 
    
	Поле sum_sale в good_sum_mart пересчиталось (продажи 1+200 штук)   
  	
	![рис.6](https://github.com/tulenevak/otus-PostgreSQL-2024-03-tuleneva/tree/main/HW14%20-%20trigger/image/im6.jpg)   	 
    
	Удалила запись   
	*delete from pract_functions.sales where sales_id =8;*  
  	
	![рис.7](https://github.com/tulenevak/otus-PostgreSQL-2024-03-tuleneva/tree/main/HW14%20-%20trigger/image/im7.jpg)   	 
   	
	В таблице good_sum_mart теперь отображается сумма только по 1й старой продаже    
  	
	![рис.8](https://github.com/tulenevak/otus-PostgreSQL-2024-03-tuleneva/tree/main/HW14%20-%20trigger/image/im8.jpg)   	 
  	
	Также добавила информацию по продажам спичек (для полной картины)   
  	
	![рис.9](https://github.com/tulenevak/otus-PostgreSQL-2024-03-tuleneva/tree/main/HW14%20-%20trigger/image/im9.jpg)   	 
  		

  
    
