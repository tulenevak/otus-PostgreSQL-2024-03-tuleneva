**Отчет ДЗ №7 Механизм блокировок**  
   
	Требуется:  
	- понимать как работает механизм блокировок объектов и строк    
  
1. Создала таблицу для тестов  
	*create table testnm.test_locks (i integer, t varchar(50));*  
	заполнила ее данными
  
	![рис.1](https://github.com/tulenevak/otus-PostgreSQL-2024-03-tuleneva/tree/main/HW07%20-%20locks/image/im1.jpg)  

	Включила логирование блокировок  
	*alter system set log_lock_waits=on;*   
  
	Включила логирование блокировок, которые удерживаются более 200 миллисекунд  
	*alter system set deadlock_timeout=200;*  
  
	Применила настройки   
	*select pg_reload_conf();*  
  
	Лог файл, где видно срабатывание, посмотрю позже.  
  
1. Запускаю update таблицы в разных сессиях (перед этим отключила автокоммит):  
	(параллельно смотрю номера транзакций, чтобы понятней был лог файл:  
	текущий идентификатор транзакции (txid) и   
	идентификатор процесса бэкенда базы данных (pg_backend_pid), который выполняет запрос)  
  
	**Session_1**  
  
	*SELECT txid_current(), pg_backend_pid();*  
	--1155819	193195  

	*update testnm.test_locks set t='H' where i=1;*  
  
	![рис.2](https://github.com/tulenevak/otus-PostgreSQL-2024-03-tuleneva/tree/main/HW07%20-%20locks/image/im2.jpg)  
    
	**Session_2**  
  
	*SELECT txid_current(), pg_backend_pid();*  
	--1155821	194093  
  
	*update testnm.test_locks set t='G' where i=1;*  
   
	**Session_3**    
  
	*SELECT txid_current(), pg_backend_pid();*  
	--1155823	194102  
  
	*update testnm.test_locks set t='F' where i=1;*  
   
	![рис.3](https://github.com/tulenevak/otus-PostgreSQL-2024-03-tuleneva/tree/main/HW07%20-%20locks/image/im3.jpg)  
  
	После запуска всех 3х сессий, судя по логу   
	(команда для запуска отображения лога tail -f /var/log/postgresql/postgresql-15-main.log),  
	сессии находятся в режиме ожидания.  
   
	![рис.4](https://github.com/tulenevak/otus-PostgreSQL-2024-03-tuleneva/tree/main/HW07%20-%20locks/image/im4.jpg)  
  
	(Здесь также видно срабатывание удерживания блокировок из п.1 ДЗ.)  
  
	В логе сообщение *Process holding the lock*:  
	означает, что процесс удерживает блокировку на конкретный объект базы данных, например, на строку, страницу или таблицу.    
	Это сообщение обычно появляется, когда другой процесс пытается получить блокировку на тот же объект,    
	но не может этого сделать, потому что первый процесс уже удерживает блокировку.  
	Процесс, удерживающий блокировку, называется *блокирующим процессом*,  
	а процесс, который пытается получить блокировку, называется *ждущим процессом*.  
  
	В логе видно по номерам транзакций, какие действия заблокированы.  
  
	*ShareLock* (блокировка общего доступа) - это блокировка режима чтения,  
	которая позволяет нескольким сеансам одновременно считывать данные  
	из заблокированной строки или страницы.  
	Ни один сеанс не может получить эксклюзивную блокировку на заблокированный объект,  
	пока он заблокирован блокировкой общего доступа.  
  
	*ExclusiveLock* (эксклюзивная блокировка) - это блокировка режима записи,  
	которая позволяет только одному сеансу одновременно записывать данные в  
	заблокированную строку или страницу.  
	Ни один другой сеанс не может получить ни блокировку общего доступа,  
	ни эксклюзивную блокировку на заблокированный объект,  
	пока он заблокирован эксклюзивной блокировкой.  
  
	Различия между *ShareLock* и *ExclusiveLock*:  

	• *Режим*: *ShareLock* - это блокировка чтения, а *ExclusiveLock* - это блокировка записи.  
	• *Совместимость*: *ShareLock* совместима с другими *ShareLock*,  
		но не совместима с *ExclusiveLock*.  
		*ExclusiveLock* несовместима ни с *ShareLock*, ни с другими *ExclusiveLock*.  
	• *Использование*: *ShareLock* используется для защиты данных от одновременного изменения,   
		в то время как *ExclusiveLock* используется для защиты данных от одновременного чтения и изменения.  
  
	Смотрю *select * from pg_catalog.pg_locks;*    
  
	Вижу эти же блокировки, что и в логе.  
   
	![рис.5](https://github.com/tulenevak/otus-PostgreSQL-2024-03-tuleneva/tree/main/HW07%20-%20locks/image/im5.jpg)  
  
1. Пробую воспроизвести взаимоблокировку:      
  
	Выполняю последовательно:  
	*update testnm.test_locks set t='X' where i=1;*	 
	*update testnm.test_locks set t='X' where i=2;*  	
	*update testnm.test_locks set t='X' where i=3;*  	
	*update testnm.test_locks set t='X' where i=2;*  	
	*update testnm.test_locks set t='X' where i=1;*  	
	*update testnm.test_locks set t='X' where i=3;*	  
   
	![рис.6](https://github.com/tulenevak/otus-PostgreSQL-2024-03-tuleneva/tree/main/HW07%20-%20locks/image/im6.jpg)  
   
	Можно посмотреть текущие процессы *SELECT query FROM pg_stat_activity WHERE state = 'active';*  
   
	![рис.7](https://github.com/tulenevak/otus-PostgreSQL-2024-03-tuleneva/tree/main/HW07%20-%20locks/image/im7.jpg)  
    
	Можно разобраться в ситуации взаимоблокировки постфактум, изучая журнал сообщений о блокировках объекта.  
	Журнал сообщений о блокировках объекта содержит информацию о том, какие процессы удерживали блокировки   
	на какие объекты и когда эти блокировки были установлены и сняты.  
	Чтобы проанализировать журнал сообщений о блокировках объекта с целью выявления взаимоблокировок,  
	необходимо выполнить следующие действия:

	- *Идентифицировать заблокированные объекты:* Найти записи в журнале, которые указывают на то,  
		что определенный объект был заблокирован. Обрать внимание на тип объекта (например, строка, страница или таблица),  
		имя объекта и идентификатор процесса (pid), удерживающий блокировку.  
	- *Определить заблокированные процессы:* Для каждого заблокированного объекта найти записи в журнале,  
		которые указывают на то, какой процесс удерживает блокировку. Обратить внимание на идентификаторы процессов (pid),  
		удерживающих блокировки.  
	- *Проверить наличие цикла блокировок:* Просмотреть журнал сообщений о блокировках объекта и проверить,  
		есть ли цикл блокировок. Цикл блокировок возникает, когда процесс A удерживает блокировку на объекте B,  
		процесс B удерживает блокировку на объекте C, а процесс C удерживает блокировку на объекте A.  
		В этом случае ни один из процессов не может продолжить выполнение, что приводит к взаимоблокировке.  
  
	Чтобы выйти из взаимоблокировки, необходимо принудительно завершить одну из заблокированных транзакций.  
	Это можно сделать с помощью команды *pg_cancel_backend*, например:
  
	*SELECT pg_cancel_backend(pid);*  
	где *pid* - это идентификатор *PID* заблокированной транзакции.  

1. Команда *UPDATE* без условия *WHERE* пытается обновить все строки в таблице.   
	Поэтому, когда первая транзакция начинает выполнять команду UPDATE,   
	она устанавливает эксклюзивную блокировку на всю таблицу,  
	чтобы предотвратить одновременное изменение данных другими транзакциями.  
  
	Если вторая транзакция попытается выполнить ту же команду UPDATE для той же таблицы,  
	она не сможет получить эксклюзивную блокировку на таблицу,  
	потому что первая транзакция уже удерживает эту блокировку.  
	В результате вторая транзакция будет заблокирована,  
	пока первая транзакция не завершит свою команду *UPDATE* и не освободит блокировку таблицы.  
  
  
	Задание со *   
	Проверяю вышесказанное на практике.  
	Запускаю на *update* таблицы без условия *where*  
   
	![рис.8](https://github.com/tulenevak/otus-PostgreSQL-2024-03-tuleneva/tree/main/HW07%20-%20locks/image/im8.jpg)  
  
	Смотрю лог после 2го update.
   
	![рис.9](https://github.com/tulenevak/otus-PostgreSQL-2024-03-tuleneva/tree/main/HW07%20-%20locks/image/im9.jpg)  
  
	После ручного *commit* на первой сессии обновление таблицы успешно завершилось.   
	Блокировка снялась.    
	Но во второй сессии обновление было отменено,    
	чтобы продолжить работу, нужно заново его запустить.    
	Делаю вывод, что взаимной блокировки не произошло.   
	Т.е. вторая сессия не смогла заблокировать выполнение первой.  